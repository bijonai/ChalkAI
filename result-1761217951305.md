Here is the high-level lesson plan for a digital interactive classroom on Binary Trees.

```markdown
---
step: 1
conditional: false
---

### 欢迎来到二叉树的世界！

你好！欢迎学习数据结构中的一个核心概念：**二叉树**。

你可能听说过数组和链表，它们都是线性的数据结构，就像一串珠子。但现实世界中的很多关系都不是线性的，比如公司的组织架构、文件系统的目录结构。

二叉树就是一种用来表示这种层级关系的强大工具。在本课程中，我们将一步步探索它。

*   **可视化图示**: 展示一个简单的组织架构图（CEO -> 多个副总 -> 多个经理），然后过渡到旁边一个抽象的二叉树形状，以说明层级关系。

---
step: 2
conditional: false
---

### 什么是二叉树？

简单来说，二叉树是一种树形结构，它遵循一个简单的规则：

> **每个节点最多有两个子节点。**

这两个子节点通常被称为“左子节点”和“右子节点”。

一个节点是树的基本组成部分，它包含：
1.  **数据** (比如一个数字或一个名字)
2.  一个指向**左子节点**的引用 (指针)
3.  一个指向**右子节点**的引用 (指针)

如果一个节点没有某个子节点（比如没有左子节点），那么对应的引用就是空的 (NULL)。

*   **可视化图示**:
    *   展示一个单独的节点，标记出三个部分：“数据 (Data)”、“左指针 (left)”和“右指针 (right)”。
    *   旁边展示一个由这个节点组成的简单三节点二叉树：一个根节点，连接着一个左子节点和一个右子节点。用箭头清晰地表示指针的指向。

---
step: 3
conditional: true
---

### 动手创建你的第一个节点

让我们来亲手创建一个节点。下面的图示代表一个空树。请点击下方的按钮，为这棵树添加一个“根节点”。根节点是树最顶端的节点。

*   **交互式画布**:
    *   初始状态显示一个空的画布，标题为“我的第一棵二叉树”。
    *   下方有一个按钮 **[添加根节点]**。

**Condition to proceed**: 学生必须点击 **[添加根节点]** 按钮。点击后，画布中央会出现一个值为随机数（例如 10）的节点。

---
step: 4
conditional: true
---

### 添加子节点

做得好！现在我们有了一个根节点。

记住，每个节点最多可以有两个子节点。现在，请尝试为我们刚刚创建的根节点添加一个左子节点和一个右子节点。

*   **交互式画布**:
    *   显示上一步创建的带根节点的树。
    *   根节点下方出现两个可点击的占位符区域，分别标记为“添加左子节点”和“添加右子节点”。
    *   当学生点击占位符时，一个新的节点会出现在相应的位置，并与根节点连接。

**Condition to proceed**: 学生必须成功添加至少一个子节点（左或右）。为了简化，我们让他们把左右子节点都加上。

---
step: 5
conditional: false
---

### 认识二叉树的“家庭成员”

和家族树一样，二叉树也有描述关系的术语。看看下面的图，我们将学习一些关键术语：

*   **可视化图示**: 展示一棵包含 5-7 个节点的二叉树，当鼠标悬浮在不同节点上时，高亮显示其关系。
    *   **根 (Root)**: 树的最顶端节点（没有父节点）。
    *   **父节点 (Parent)**: 一个拥有子节点的节点。
    *   **子节点 (Child)**: 一个有父节点的节点。
    *   **叶节点 (Leaf)**: 没有子节点的节点。
    *   **兄弟节点 (Siblings)**: 拥有相同父节点的两个节点。

*   **文本说明**: 在图示旁边，用清晰的文字解释以上每个术语。
    *   例如：“将鼠标悬停在值为 5 的节点上，你会看到它的父节点是 8，它的兄弟节点是 12。”

---
step: 6
conditional: true
---

### 小测验：识别节点关系

现在，检验一下你是否掌握了这些术语。在下面的树中，节点 `25` 的父节点是哪个？

*   **可视化图示**: 展示一棵固定的二叉树，例如：
    ```
        50
       /  \
      17   72
     /  \
    12  25
    ```
*   **选择题 (chooser)**:
    *   A) 50
    *   B) 17
    *   C) 72
    *   D) 12

**Condition to proceed**: 学生必须选择正确答案 B)。如果选错，会提示“再想想，父节点是直接连接在它上方的节点”。

---
step: 7
conditional: false
---

### 二叉树的“身高”—— 高度与深度

我们经常需要衡量树的“大小”。有两个重要的指标：

*   **深度 (Depth)**: 从根节点到某个节点所经过的路径长度。根节点的深度为 0。
*   **高度 (Height)**: 从某个节点到其最远叶节点所经过的路径长度。叶节点的高度为 0。树的高度等于根节点的高度。

*   **交互式图示**:
    *   显示一棵二叉树。
    *   当学生点击任意一个节点时，动态地显示该节点的**深度**和**高度**。
    *   例如，点击根节点，显示 "深度: 0, 高度: 3"。点击一个叶节点，显示 "深度: 3, 高度: 0"。

---
step: 8
conditional: false
---

### 特殊的二叉树

虽然所有二叉树都遵循“最多两个子节点”的规则，但有一些特殊的类型非常重要：

*   **分页器 (paginator)**: 使用选项卡来展示不同类型的二叉树。

    *   **选项卡1: 满二叉树 (Full Binary Tree)**
        *   **说明**: 在这种树中，除了叶节点外，每个节点都有两个子节点。就像一个完美的金字塔。
        *   **图示**: 展示一个完美的、每层都填满的二叉树。

    *   **选项卡2: 完全二叉树 (Complete Binary Tree)**
        *   **说明**: 这种树除了最后一层外，其他层都是满的，并且最后一层的节点都尽可能地靠左排列。
        *   **图示**: 展示一个类似满二叉树，但最后一层缺少右边几个节点的例子。

    *   **选项卡3: 二叉搜索树 (Binary Search Tree - BST)**
        *   **说明**: 这是最有用的二叉树之一！它有一个特殊的排序规则：
            1.  所有左子树节点的值都 **小于** 根节点的值。
            2.  所有右子树节点的值都 **大于** 根节点的值。
            3.  它的左右子树也都是二叉搜索树。
        *   **图示**: 展示一个符合 BST 规则的树，例如根为 50，左子节点为 30，右子节点为 70。

---
step: 9
conditional: true
---

### 探索二叉搜索树 (BST)

二叉搜索树的排序规则使得查找、插入和删除操作非常高效。

让我们来验证一下。下面的树是一棵二叉搜索树吗？

*   **可视化图示**:
    ```
        20
       /  \
      15   30
     /  \
    10  18
    ```

*   **选择题 (chooser)**:
    *   A) 是，它符合 BST 的所有规则。
    *   B) 否，因为 `18` 比 `15` 大，但它在 `15` 的右边。
    *   C) 否，因为 `18` 比 `20` 小，但它在 `20` 的右子树中。

**Condition to proceed**: 学生必须选择正确答案 A)。选项 C 是一个常见的误解，需要澄清：`18` 确实比 `20` 小，但它首先是 `15` 的右孩子（`18 > 15`），而 `15` 是 `20` 的左孩子，所以整体规则没有被破坏。如果选错，给出相应的提示。

---
step: 10
conditional: false
---

### 遍历：访问树中的每一个节点

现在我们已经了解了树的结构，下一个问题是：如何系统地访问树中的每一个节点？这个过程称为**遍历**。

主要有三种深度优先的遍历方式：
1.  **前序遍历 (Pre-order)**: 根 → 左 → 右
2.  **中序遍历 (In-order)**: 左 → 根 → 右
3.  **后序遍历 (Post-order)**: 左 → 右 → 根

“前”、“中”、“后”指的是**根节点**在何时被访问。

让我们通过一个动画来理解这个过程。

---
step: 11
conditional: false
---

### 动画演示：前序遍历 (根 → 左 → 右)

在前序遍历中，我们遵循“先访问当前节点，然后访问左子树，最后访问右子树”的顺序。

*   **交互式动画**:
    *   **图示**: 展示一棵固定的示例树。
        ```
            F
           / \
          B   G
         / \   \
        A   D   I
           / \
          C   E
        ```
    *   **控制**: 提供一个 **[下一步]** 按钮。
    *   **动画过程**:
        1.  开始时，一个“访问指针”指向根节点 `F`。`F` 被高亮，并被添加到下方的“遍历结果”列表中。
        2.  点击 **[下一步]**，指针移向 `F` 的左子节点 `B`。`B` 被高亮并添加到结果列表。
        3.  继续点击，会按照 `A`, `D`, `C`, `E`, `G`, `I` 的顺序依次访问。每一步都高亮当前节点，并在结果列表中显示。
    *   **结果显示**: 一个文本区域实时显示遍历结果：`F, B, A, D, C, E, G, I`

---
step: 12
conditional: true
---

### 练习：你的前序遍历

现在轮到你了。对于下面的树，它的前序遍历结果是什么？

*   **可视化图示**: 展示一个新的、简单的二叉树。
    ```
        10
       /  \
      5    15
     /      \
    3        20
    ```
*   **输入题 (input)**: 提供一个输入框，让学生输入用逗号分隔的数字序列。

**Condition to proceed**: 学生必须输入正确的前序遍历序列 `10,5,3,15,20`。忽略空格和末尾的逗号。如果错误，提示“再试一次！记住顺序是：根 → 左 → 右”。

---
step: 13
conditional: false
---

### 动画演示：中序遍历 (左 → 根 → 右)

在中序遍历中，我们遵循“先访问左子树，然后访问当前节点，最后访问右子树”的顺序。

对于二叉搜索树 (BST) 来说，中序遍历会得到一个**有序**的序列！

*   **交互式动画**:
    *   **图示**: 使用与前序遍历相同的示例树。
    *   **控制**: 提供 **[下一步]** 按钮。
    *   **动画过程**:
        1.  动画将展示指针如何先深入到最左边的节点 `A`。
        2.  访问 `A`，然后是其父节点 `B`，然后是 `B` 的右子树 (`C`, `D`, `E`)。
        3.  整个过程会按照 `A, B, C, D, E, F, G, I` 的顺序进行。
    *   **结果显示**: 实时更新遍历结果列表。

---
step: 14
conditional: true
---

### 练习：你的中序遍历

对于我们之前用过的这棵树，它的中序遍历结果是什么？

*   **可视化图示**: 再次展示练习用的树。
    ```
        10
       /  \
      5    15
     /      \
    3        20
    ```
*   **输入题 (input)**: 提供一个输入框。

**Condition to proceed**: 学生必须输入正确的中序遍历序列 `3,5,10,15,20`。如果错误，提示“想想看，对于二叉搜索树，中序遍历的结果应该是什么样的？”

---
step: 15
conditional: false
---

### 动画演示：后序遍历 (左 → 右 → 根)

在后序遍历中，我们遵循“先访问左子树，然后访问右子树，最后访问当前节点”的顺序。这种遍历方式常用于计算表达式树或安全地删除树中的节点（因为你可以在删除父节点之前先处理完所有子节点）。

*   **交互式动画**:
    *   **图示**: 使用相同的示例树。
    *   **控制**: 提供 **[下一步]** 按钮。
    *   **动画过程**:
        1.  动画展示指针如何先处理完整个左子树 (`A, C, E, D, B`)，再处理完右子树 (`I, G`)，最后才访问根节点 `F`。
        2.  整个过程会按照 `A, C, E, D, B, I, G, F` 的顺序进行。
    *   **结果显示**: 实时更新遍历结果列表。

---
step: 16
conditional: true
---

### 综合测验：匹配遍历方式

你已经学完了三种主要的遍历方式。现在，将下面的遍历结果与它们的类型匹配起来。

*   **可视化图示**:
    ```
        M
       / \
      G   S
     / \   \
    D   J   W
    ```
*   **拖放匹配题**:
    *   **选项**: "前序遍历", "中序遍历", "后序遍历"
    *   **目标**:
        *   `M, G, D, J, S, W`
        *   `D, G, J, M, S, W`
        *   `D, J, G, W, S, M`

**Condition to proceed**: 学生必须将 "前序遍历" 拖到 `M, G, D, J, S, W`，"中序遍历"拖到 `D, G, J, M, S, W`，"后序遍历"拖到 `D, J, G, W, S, M`。

---
step: 17
conditional: false
---

### leveled traversal - a different way to look at the tree

Now, you have learned the three most common ways to traversal a binary tree, let's learn a new way to traversal a tree, which is called **leveled traversal**.

Leveled traversal is a way to traverse a tree by visiting all the nodes at the same level before moving to the next level. For example, in the following tree:

```
    A
   / \
  B   C
 / \ / \
D  E F  G
```

The leveled traversal will be `A, B, C, D, E, F, G`.

*   **交互式动画**:
    *   **图示**: 使用相同的示例树。
    *   **控制**: 提供 **[下一步]** 按钮。
    *   **动画过程**:
        1.  动画展示指针如何先访问根节点 `A`，然后是 `B` 和 `C`，然后是 `D`, `E`, `F`, `G`。
        2.  整个过程会按照 `A, B, C, D, E, F, G` 的顺序进行。
    *   **结果显示**: 实时更新遍历结果列表。

---
step: 18
conditional: true
---

### 练习：你的 leveled traversal

对于我们之前用过的这棵树，它的 leveled traversal 结果是什么？

*   **可视化图示**: 再次展示练习用的树。
    ```
        10
       /  \
      5    15
     /      \
    3        20
    ```
*   **输入题 (input)**: 提供一个输入框。

**Condition to proceed**: 学生必须输入正确的 leveled traversal 序列 `10,5,15,3,20`。如果错误，提示“再试一次！记住顺序是：从上到下，从左到右”。

---
step: 19
conditional: false
---

### The code behind traversal (Pre-order)

Let's see the code behind the traversal. We will use the pre-order traversal as an example. The code is very simple and elegant with recursion.

*   **代码块 (code)**:
```c
// 定义树节点结构
struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
};

// 前序遍历函数
void preOrder(TreeNode* root) {
    if (root == NULL) {
        return; // 如果节点为空，直接返回
    }
    
    // 1. 访问根节点
    printf("%d ", root->data);
    
    // 2. 递归遍历左子树
    preOrder(root->left);
    
    // 3. 递归遍历右子树
    preOrder(root->right);
}
```
*   **文本说明**:
    这段代码完美地体现了“根→左→右”的思想。`if (root == NULL)` 是递归的终止条件，这非常重要，它防止了无限循环。

---
step: 20
conditional: false
---

### 二叉搜索树的操作：查找 (Search)

二叉搜索树（BST）最强大的功能之一就是快速查找。因为它的节点是按特定规则排序的。

假设我们要查找 `25`。

*   **交互式动画**:
    *   **图示**: 展示一棵 BST。
        ```
            50
           /  \
          17   72
         /  \
        12  25
        ```
    *   **说明**: "目标: 查找 25"
    *   **动画**:
        1.  从根 `50` 开始。`25 < 50`，所以我们向**左**走。
        2.  到达 `17`。`25 > 17`，所以我们向**右**走。
        3.  到达 `25`。找到了！
    *   **高亮**: 动画会高亮走过的路径 `50 -> 17 -> 25`。

---
step: 21
conditional: true
---

### 二叉搜索树的操作：插入 (Insert)

插入一个新节点和查找非常类似。我们首先找到它应该在的位置，然后把它放进去。

现在，请你试着将数字 `23` 插入到下面的 BST 中。你应该点击哪个节点，让 `23` 成为它的子节点？

*   **交互式画布**:
    *   展示与上一步相同的 BST。
    *   当学生鼠标悬停在节点上时，显示“添加左子节点”和“添加右子节点”的占位符（如果该位置为空）。
    *   学生需要点击正确的占位符。

*   **说明**: "任务: 插入 23"

**Condition to proceed**: 学生必须点击节点 `25` 下方的“左子节点”占位符。
*   路径应该是：从 `50` 到 `17` (左)，从 `17` 到 `25` (右)。因为 `23 < 25`，所以 `23` 应该是 `25` 的左子节点。
*   若点击错误，提示：“想一想，`23` 和路径上的节点相比，是大还是小？”

---
step: 22
conditional: false
---

### 课程总结与展望

恭喜你！你已经完成了二叉树基础课程！

我们学习了：
*   **二叉树的基本定义**、术语和特殊类型（满二叉树、完全二叉树、BST）。
*   **四种核心的遍历方式**：前序、中序、后序和层序。
*   **二叉搜索树（BST）** 的查找和插入操作。

这只是冰山一角！二叉树是许多高级算法和数据结构的基础，例如：
*   **平衡二叉树 (AVL 树, 红黑树)**: 解决了普通 BST 可能退化成链表的问题，确保操作高效。
*   **堆 (Heap)**: 一种特殊的完全二叉树，用于实现优先队列。
*   **Trie 树**: 用于高效的字符串查找。

继续探索，你会发现数据结构的世界充满了智慧和乐趣！
```